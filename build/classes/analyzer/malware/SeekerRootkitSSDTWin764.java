/* 
 * Copyright (C) 2016 BIP-M Framework.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
package analyzer.malware;

import analyzer.libs.SeekerLib;
import analyzer.libs.SeekerLibWin764;
import static analyzer.malware.SeekerRootkitSSDT._suspiciousInstructions;
import analyzer.processes.SeekerProcessWin764;
import analyzer.states.ActiveProcessWin764;
import entities.Entity;
import entities.lib.EntityLib;
import entities.malware.EntityHook;
import entities.malware.EntityPointerReplacementSSDTHook;
import entities.malware.EntityRootkit;
import entities.malware.EntitySDE;
import entities.malware.EntitySSDT;
import entities.malware.EntityDuplicationSSDTHook;
import entities.malware.EntityInLineSSDTHook;
import entities.malware.EntityWin764SDE;
import entities.malware.EntityWin764SSDTRootkit;
import entities.malware.EntityWindowsFunction;
import entities.malware.EntityWindowsFunctionOperation;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import output.OutputManagerAnalyzer;
import output.OutputManagerException;
import persistence.analyzer_service.PersistenceObject;
import system.utils.Conversor;

/**
 *
 * @author Gonzalo
 */
public class SeekerRootkitSSDTWin764 extends SeekerRootkitSSDT {

    public SeekerRootkitSSDTWin764() {
        this._seekerProcess = new SeekerProcessWin764(new ActiveProcessWin764(this.getAService()));
        this._seekerLib = new SeekerLibWin764(this.getAService());

        /**
         * Registra observadores
         */
        this.addObserver(OutputManagerException.getInstance());
        this.addObserver(OutputManagerAnalyzer.getInstance());
    }

    public SeekerRootkitSSDTWin764(PersistenceObject persistenceObject) {
        super(persistenceObject);
        this._seekerProcess = new SeekerProcessWin764(new ActiveProcessWin764(this.getAService()));
        this._seekerLib = new SeekerLibWin764(this.getAService());

        /**
         * Registra observadores
         */
        this.addObserver(OutputManagerException.getInstance());
        this.addObserver(OutputManagerAnalyzer.getInstance());
    }

    public SeekerLib getSeekerLib() {
        return _seekerLib;
    }

    public void setSeekerLib(SeekerLib _seekerLib) {
        this._seekerLib = _seekerLib;
    }

    public void setAService(PersistenceObject persistenceObject) {
        super.setAService(persistenceObject);
        if (this._seekerProcess != null) {
            this._seekerProcess.setAService(persistenceObject);
        }
        if (this._seekerLib != null) {
            this._seekerLib.setAService(persistenceObject);
        }
    }

    @Override
    public List<EntityRootkit> getSSDTHooks() {
        List<EntityRootkit> ssdtRootkitList = null;

        try {
            /**
             * Notifica a observadores
             */
            String log = "Se solicita registros de Malware tipo = " + SeekerRootkitSSDT._MALWARE_TYPE + ".";
            this.notifyObservers(log);

            ssdtRootkitList = this.getAService().getRootkitList(this, new EntityWin764SSDTRootkit(), null);
            if (ssdtRootkitList != null) {
                for (Entity e : ssdtRootkitList) {
                    EntityWin764SSDTRootkit p = (EntityWin764SSDTRootkit) e;
                    ssdtRootkitList.add(p);
                    this.notifyObservers(p);
                }
            } else {
                /**
                 * Comienza el proceso
                 */
                ConcurrentHashMap<String, String> ssdtVAList = null;

                /**
                 * Obtener módulos cargados en memoria
                 */
                SeekerLibWin764 seekerLib = (SeekerLibWin764) this._seekerLib;
                List<EntityLib> libList = seekerLib.getLibList();

                /**
                 * Obtiene dirección base de ntoskrnl.exe
                 */
                EntityLib ntoskrnl = libList.get(0);
                String dllBaseHex = (String) ntoskrnl.getAttributes().get("DllBase").getContent();
                BigInteger dllBase = Conversor.hexToBigInteger(dllBaseHex);

                log = "Obtener listado de SSDT...";
                this.notifyObservers(log);
                List<EntitySSDT> ssdtList = new ArrayList<EntitySSDT>();
                ssdtList = seekerLib.getSSDTList(dllBase, ssdtList);

                /**
                 * Otra implementación sería buscar las SSDTs en un sólo método
                 * seekerLib.getSSDTList(BigInteger.ZERO);
                 */
                this._ssdtList = ssdtList;

                /**
                 * Inicializa colección de rootkit
                 */
                ssdtRootkitList = new ArrayList<EntityRootkit>();

                /**
                 * Analiza existencia de Table Duplication Hooks
                 */
                log = "Buscando Hooks del tipo: " + EntityDuplicationSSDTHook._TAG + "...";
                this.notifyObservers(log);
                List<EntityHook> tableDuplicationHookList = this.findTableDumplicationHooks(this._ssdtList);
                EntityWin764SSDTRootkit rootTD = new EntityWin764SSDTRootkit();
                rootTD.setHookList(tableDuplicationHookList);
                ssdtRootkitList.add(rootTD);

                /**
                 * Analiza existencia de Pointer Replacement Hooks
                 */
                log = "Buscando Hooks del tipo: " + EntityPointerReplacementSSDTHook._TAG + "...";
                this.notifyObservers(log);
                List<EntityHook> pointerRplmntHookList = this.findPointerReplacementHooks(libList, this._ssdtList);
                EntityWin764SSDTRootkit rootPR = new EntityWin764SSDTRootkit();
                rootPR.setHookList(pointerRplmntHookList);
                ssdtRootkitList.add(rootPR);

                /**
                 * Analiza existencia de InLine Hooks
                 */
                log = "Buscando Hooks del tipo: " + EntityInLineSSDTHook._TAG + "...";
                this.notifyObservers(log);
                List<EntityHook> inLineHookList = this.findInLineHooks(this._ssdtList);
                EntityWin764SSDTRootkit rootIL = new EntityWin764SSDTRootkit();
                rootIL.setHookList(inLineHookList);
                ssdtRootkitList.add(rootIL);

            }

            /**
             * Notifica a observadores
             */
            int cantMalwareRegisters = 0;
            if (ssdtRootkitList != null) {
                cantMalwareRegisters = ssdtRootkitList.size();

                /**
                 * Persiste resultados
                 */
                log = "Persistiendo resultados...";
                this.notifyObservers(log);
                Map<Object, Entity> mapRoot = new HashMap<Object, Entity>();
                int r = 0;
                for (EntityRootkit root : ssdtRootkitList) {
                    mapRoot.put(r++, root);
                }
                this.persistResults(mapRoot);
            }
            log = "Finalizó la búsqueda de registros de Malware tipo = " + SeekerRootkitSSDT._MALWARE_TYPE + ".";
            this.notifyObservers(log);
            log = "Tipos de Malware analizados = " + cantMalwareRegisters + ".";
            this.notifyObservers(log);
        } catch (Exception ex) {
            this.notifyObservers(ex);
            ex.printStackTrace();
        }

        return ssdtRootkitList;
    }

    @Override
    public List<EntityHook> findPointerReplacementHooks(List<EntityLib> libList, List<EntitySSDT> ssdtList) {
        ArrayList<EntityHook> hookList = null;
        String hookType = EntityPointerReplacementSSDTHook._HOOK_TYPE;

        try {
            hookList = new ArrayList<EntityHook>();
            EntityLib lib = libList.get(0);
            String dllBaseVAHex = (String) lib.getAttributes().get("DllBase").getContent();
            String sizeHex = (String) lib.getAttributes().get("SizeOfImage").getContent();
            long dllBase = lib.getDllBaseOffset();
            long size = Conversor.hexToLong(sizeHex);
            long dllEnd = dllBase + size;

            for (EntitySSDT s : ssdtList) {
                boolean hookPresent = false;
                EntityPointerReplacementSSDTHook hook = new EntityPointerReplacementSSDTHook();
                for (EntitySDE e : s.getEntryList()) {
                    if (e != null) {
                        List<EntityWindowsFunction> hookedFunctionList = new ArrayList<EntityWindowsFunction>();
                        for (EntityWindowsFunction f : e.getFunctionArray()) {
                            long fOffset = f.getOffset();
                            if (fOffset < dllBase && fOffset > dllEnd) { //Hook encontrado
                                hookPresent = true;
                                f.setHooked(hookPresent);
                                f.setHookType(hookType);
                                hookedFunctionList.add(f);
                            }
                        }
                        if (hookPresent) {
                            hook.setHookedFunctionList(hookedFunctionList);
                        }
                    }
                }

                /**
                 * Prepara colección de hooks a devolver
                 */
                if (hookPresent) {
                    hook.setHookedSSDT(s);
                    hookList.add(hook);
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return hookList;
    }

    @Override
    public List<EntityHook> findTableDumplicationHooks(List<EntitySSDT> ssdtList) {
        List<EntityHook> hookList = null;
        String hookType = EntityDuplicationSSDTHook._HOOK_TYPE;

        try {
            hookList = new ArrayList<EntityHook>();

            /**
             * Separa las tablas conocidas
             */
            EntitySSDT keServiceDescriptorTable = ssdtList.get(0);
            EntitySSDT keServiceDescriptorTableShadow = ssdtList.get(1);
            EntitySDE[] sdeList = keServiceDescriptorTable.getEntryList();
            EntitySDE kiServiceTable = sdeList[0];
            EntitySDE[] sdeListShadow = keServiceDescriptorTableShadow.getEntryList();
            EntitySDE kiServiceTableShadow = sdeListShadow[0];
            EntitySDE w32pServiceTable = sdeListShadow[1];

            for (int i = 1; i < 2; i++) {
                /**
                 * Analizo de KeServiceDescriptorTable, comparando con el resto
                 */
                if (sdeList[i] != null) {
                    if (sdeList[i].isValid()) {
                        this.doCompareFunctions(sdeList[i], kiServiceTable, hookType);
                        this.doCompareFunctions(sdeList[i], kiServiceTableShadow, hookType);
                    }
                }
                /**
                 * Analizo de KeServiceDescriptorTableShadow, comparando con el
                 * resto
                 */
                if (sdeListShadow[i] != null) {
                    if (sdeListShadow[i].isValid()) {
                        this.doCompareFunctions(sdeListShadow[i], kiServiceTable, hookType);
                        this.doCompareFunctions(sdeListShadow[i], kiServiceTableShadow, hookType);
                    }
                }
            }

            /**
             * Prepara colección de hooks a devolver
             */
            EntityDuplicationSSDTHook hook = new EntityDuplicationSSDTHook();
            for (EntitySSDT s : ssdtList) {
                for (EntitySDE e : s.getEntryList()) {
                    if (e != null) {
                        if (e.isHooked()) {
                            hook.setDuplicatedSDE(e);
                            hookList.add(hook);
                        }
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return hookList;
    }

    @Override
    public List<EntityHook> findInLineHooks(List<EntitySSDT> ssdtList) {
        List<EntityHook> hookList = null;
        String hookType = "InLine Hook";

        try {
            hookList = new ArrayList<EntityHook>();
            /**
             * Obtener las operaciones de las funciones en la colección de SDEs
             * de las SSDTs. Comparar con las _suspociousOperations
             */
            for (EntitySSDT s : ssdtList) {
                boolean hookPresent = false;
                for (EntitySDE sde : s.getEntryList()) {
                    if (sde != null) {
                        for (EntityWindowsFunction f : sde.getFunctionArray()) {
                            if (f != null) {
                                for (EntityWindowsFunctionOperation op : f.getOperations()) {
                                    if (op != null) {
                                        for (String opStr : _suspiciousInstructions) {
                                            String operation = (String) op.getAttributes().get("operation").getContent();
                                            if (operation != null) {
                                                if (operation.contains(opStr)) { // Posible InLine Hook
                                                    hookPresent = true;
                                                    op.setHooked(hookPresent);
                                                    op.setHookType(hookType);
                                                }
                                            }
                                        }
                                    }
                                    if (hookPresent) {
                                        f.setHooked(hookPresent);
                                        f.setHookType(hookType);
                                    }
                                }
                            }
                        }
                    }
                }

                /**
                 * Prepara colección de hooks a devolver
                 */
                EntityInLineSSDTHook hook = new EntityInLineSSDTHook();
                if (hookPresent) {
                    hook.setHookedSSDT(s);
                    hookList.add(hook);
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return hookList;
    }

    @Override
    public EntityRootkit getFirstRootkit() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public EntityRootkit getNextRootkit(EntityRootkit rootkit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public EntityRootkit getPrevRootkit(EntityRootkit rootkit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Entity getEntityByAttributeValue(Entity entity, String attribute, Object content) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void doCompareFunctions(EntitySDE suspicious, EntitySDE knownSSDT, String hookType) {

        try {
            int cantFuncionesIguales = 0;
            int cantFuncionesDistintas = 0;
            /**
             * Compara la cantidad de entries
             */
            if (suspicious instanceof EntityWin764SDE) {
                if (suspicious.getServiceLimit() == knownSSDT.getServiceLimit()) {
                    /**
                     * Comparar funciones. Según porcentajes, definir si es un
                     * hook de duplicación
                     */
                    EntityWindowsFunction[] sdeFunctions = suspicious.getFunctionArray();
                    EntityWindowsFunction[] kiServiceTableFunctions = knownSSDT.getFunctionArray();
                    for (int j = 0; j < suspicious.getServiceLimit(); j++) {
                        if (sdeFunctions[j].getFunctionVA() == kiServiceTableFunctions[j].getFunctionVA()) {
                            cantFuncionesIguales++;
                        } else {
                            cantFuncionesDistintas++;
                            sdeFunctions[j].setHooked(true);
                            sdeFunctions[j].setHookType(hookType);
                        }
                    }

                    float razonDist = cantFuncionesDistintas / (cantFuncionesIguales + cantFuncionesDistintas);
                    if (razonDist == 1) { // Es otra tabla
                        for (int k = 0; k < suspicious.getServiceLimit(); k++) { // Limpia las 
                            cantFuncionesDistintas++;
                            sdeFunctions[k].setHooked(true);
                            sdeFunctions[k].setHookType(hookType);
                        }
                    } else {
                        suspicious.setHooked(true);
                        suspicious.setFunctionArray(sdeFunctions);
                        suspicious.setDuplicatedWith(knownSSDT.getFunctionTableVAHex());
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public void doAnalizeFunctionOperations(EntitySDE sde, String hookType) {
        try {
            if (sde != null) {
                EntityWindowsFunction[] functionList = sde.getFunctionArray();
                int i = 0;
                boolean hooked = false;
                for (EntityWindowsFunction f : functionList) {
                    if (f != null) {
                        EntityWindowsFunctionOperation[] operations = f.getOperations();
                        for (EntityWindowsFunctionOperation op : operations) {
                            for (String instruction : _suspiciousInstructions) {
                                String operation = (String) op.getAttributes().get("operation").getContent();
                                if (operation.contains(instruction)) { // Inline Hook Suspicious
                                    f.setHooked(true);
                                    f.setHookType(hookType);
                                    op.setHooked(true);
                                    op.setHookType(hookType);
                                    hooked = true;
                                }
                            }
                        }
                    }
                }

                sde.setHooked(hooked);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public List<EntitySSDT> getSSDTList(BigInteger virtualAddress) {
        List<EntitySSDT> ssdtList = null;

        return ssdtList;
    }
}
