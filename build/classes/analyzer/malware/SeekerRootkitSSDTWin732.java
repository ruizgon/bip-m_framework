/* 
 * Copyright (C) 2016 BIP-M Framework.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
package analyzer.malware;

import analyzer.libs.SeekerLibWin732;
import analyzer.processes.SeekerProcessWin732;
import analyzer.states.ActiveProcessWin732;
import entities.Entity;
import entities.EntityUnicodeStringWin32;
import entities.lib.EntityLib;
import entities.malware.EntityDuplicationSSDTHook;
import entities.malware.EntityHook;
import entities.malware.EntityInLineSSDTHook;
import entities.malware.EntityPointerReplacementSSDTHook;
import entities.malware.EntityRootkit;
import entities.malware.EntitySDE;
import entities.malware.EntitySSDT;
import entities.malware.EntityWin732SDE;
import entities.malware.EntityWin732SSDT;
import entities.malware.EntityWin732SSDTRootkit;
import entities.malware.EntityWindowsFunction;
import entities.malware.EntityWindowsFunctionOperation;
import entities.process.EntityProcess;
import entities.process.EntityThread;
import entities.process.EntityWin732KTHREAD;
import entities.translation.EntityAddressSpace;
import entities.translation.EntityAddressSpaceWin32;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import persistence.analyzer_service.PersistenceObject;
import system.utils.Conversor;

/**
 *
 * @author Gonzalo
 */
public class SeekerRootkitSSDTWin732 extends SeekerRootkitSSDT {

    public SeekerRootkitSSDTWin732() {
        this._seekerProcess = new SeekerProcessWin732(new ActiveProcessWin732(this.getAService()));
        this._seekerLib = new SeekerLibWin732(this.getAService());
    }

    public SeekerRootkitSSDTWin732(PersistenceObject persistenceObject) {
        super(persistenceObject);
        this._seekerProcess = new SeekerProcessWin732(new ActiveProcessWin732(this.getAService()));
        this._seekerLib = new SeekerLibWin732(this.getAService());
    }

    public void setAService(PersistenceObject persistenceObject) {
        super.setAService(persistenceObject);
        if (this._seekerProcess != null) {
            this._seekerProcess.setAService(persistenceObject);
        }
        if (this._seekerLib != null) {
            this._seekerLib.setAService(persistenceObject);
        }
    }

    @Override
    public List<EntityRootkit> getSSDTHooks() {
        List<EntityRootkit> ssdtRootkitList = null;

        try {
            /**
             * Notifica a observadores
             */
            String log = "Se solicita registros de Malware tipo = " + SeekerRootkitSSDT._MALWARE_TYPE + ".";
            this.notifyObservers(log);

            ArrayList<EntityRootkit> rootkitList = this.getAService().getRootkitList(this, new EntityWin732SSDTRootkit(), null);
            if (rootkitList != null) {
                for (Entity e : rootkitList) {
                    EntityWin732SSDTRootkit p = (EntityWin732SSDTRootkit) e;
                    ssdtRootkitList.add(p);
                    this.notifyObservers(p);
                }
            } else {
                /**
                 * Instancia Seeker
                 */

                SeekerProcessWin732 seekerProcess = (SeekerProcessWin732) this._seekerProcess;
                /**
                 * Comienza el proceso
                 */
                ConcurrentHashMap<String, String> ssdtVAList = null;

                /**
                 * Se solicita listado de procesos
                 */
                log = "Se solicita listado de procesos...";
                this.notifyObservers(log);

                List<EntityProcess> processList = seekerProcess.getProcessList();

                /**
                 * Se solicta lista de threads de cada proceso
                 */
                log = "Se solicita listado de threads por proceso...";
                this.notifyObservers(log);
                ArrayList<EntityThread> threads = new ArrayList<EntityThread>();
                for (EntityProcess p : processList) {
                    ArrayList<EntityThread> threadsByProcess = seekerProcess.getThreadsByProcess(p);
                    for (EntityThread t : threadsByProcess) {
                        threads.add(t);
                    }
                }

                /**
                 * Se solcita punteros únicos a las Service Table
                 */
                ssdtVAList = new ConcurrentHashMap<String, String>();
                for (EntityThread t : threads) {
                    EntityWin732KTHREAD kThread = (EntityWin732KTHREAD) t.getAttributes().get("KTHREAD").getEntity();
                    if (kThread.getAttributes().get("SSDT").isValid()) {
                        String ssdtVA = (String) kThread.getAttributes().get("SSDT").getContent();
                        ssdtVAList.put(ssdtVA, "Entrada encontrada.");
                    }
                }

                /**
                 * Obtener módulos cargados en memoria
                 */
                log = "Se solicita listado de módulos...";
                this.notifyObservers(log);
                SeekerLibWin732 seekerLib = (SeekerLibWin732) this._seekerLib;
                List<EntityLib> libList = seekerLib.getLibList();

                /**
                 * Busca Service Descriptor Tables (SDTs), en base a los VA
                 * obtenidos en ssdtVAList: KeServiceDescriptorTable
                 * KeServiceDescriptorTableShadow
                 */
                log = "Obtener listado de SSDT...";
                this.notifyObservers(log);
                List<EntitySSDT> ssdtList = new ArrayList<EntitySSDT>();
                Iterator<Map.Entry<String, String>> i = ssdtVAList.entrySet().iterator();
                while (i.hasNext()) {
                    Map.Entry<String, String> entry = (Map.Entry<String, String>) i.next();
                    EntitySSDT s = new EntityWin732SSDT();
                    EntityAddressSpace aS = new EntityAddressSpaceWin32();
                    aS.setVirtualAddressHex(entry.getKey());
                    aS.setVirtualAddress(Conversor.hexToBigInteger(entry.getKey()));
                    s.setaS(aS);
                    ssdtList.add(s);
                }
                ssdtList = seekerLib.getSSDTList(null, ssdtList);

                /**
                 * Otra implementación sería buscar las SSDTs en un sólo método
                 * seekerLib.getSSDTList(BigInteger.ZERO);
                 */
                this._ssdtList = ssdtList;

                /**
                 * Inicializa colección de rootkit
                 */
                ssdtRootkitList = new ArrayList<EntityRootkit>();
                /**
                 * Analiza existencia de Table Duplication Hooks
                 */
                log = "Buscando Hooks del tipo: " + EntityDuplicationSSDTHook._TAG + "...";
                this.notifyObservers(log);
                List<EntityHook> tableDuplicationHookList = this.findTableDumplicationHooks(this._ssdtList);
                EntityWin732SSDTRootkit rootTD = new EntityWin732SSDTRootkit();
                rootTD.setHookList(tableDuplicationHookList);
                ssdtRootkitList.add(rootTD);

                /**
                 * Analiza existencia de Pointer Replacement Hooks
                 */
                log = "Buscando Hooks del tipo: " + EntityPointerReplacementSSDTHook._TAG + "...";
                this.notifyObservers(log);
                List<EntityHook> pointerRplmntHookList = this.findPointerReplacementHooks(libList, this._ssdtList);
                EntityWin732SSDTRootkit rootPR = new EntityWin732SSDTRootkit();
                rootPR.setHookList(pointerRplmntHookList);
                ssdtRootkitList.add(rootPR);

                /**
                 * Analiza existencia de InLine Hooks
                 */
                log = "Buscando Hooks del tipo: " + EntityInLineSSDTHook._TAG + "...";
                this.notifyObservers(log);
                List<EntityHook> inLineHookList = this.findInLineHooks(this._ssdtList);
                EntityWin732SSDTRootkit rootIL = new EntityWin732SSDTRootkit();
                rootIL.setHookList(inLineHookList);
                ssdtRootkitList.add(rootIL);
            }

            /**
             * Notifica a observadores
             */
            int cantMalwareRegisters = 0;
            if (ssdtRootkitList != null) {
                cantMalwareRegisters = ssdtRootkitList.size();

                Map<Object, Entity> mapRoot = new HashMap<Object, Entity>();
                int r = 0;
                for (EntityRootkit root : ssdtRootkitList) {
                    mapRoot.put(r++, root);
                }
                this.persistResults(mapRoot);
            }
            log = "Finalizó la búsqueda de registros de Malware tipo = " + SeekerRootkitSSDT._MALWARE_TYPE + ".";
            this.notifyObservers(log);
            log = "Tipos de Malware analizados = " + cantMalwareRegisters + ".";
            this.notifyObservers(log);
        } catch (Exception ex) {
            this.notifyObservers(ex);
        }

        return ssdtRootkitList;
    }

    @Override
    public List<EntityHook> findPointerReplacementHooks(List<EntityLib> libList, List<EntitySSDT> ssdtList) {
        ArrayList<EntityHook> hookList = null;
        String hookType = EntityPointerReplacementSSDTHook._HOOK_TYPE;

        try {
            /**
             * Análisis para SSDT[0]
             */
            hookList = new ArrayList<EntityHook>();
            EntityLib lib = libList.get(0);
            /**
             * Se pueden utilizar los diccionarios para validar contra todos los
             * módulos conocidos
             */
            /*for(EntityLib l : libList){
             for(String s : _ssdt0Dict){
             EntityUnicodeStringWin32 uni = (EntityUnicodeStringWin32) l.getAttributes().get("BaseDllName").getContent();
             String lName = (String) uni.getAttributes().get("Name").getContent();
             if(lName.trim().equals(s)){
             lib = l;
             }
             }
             }*/
            String sizeHex = (String) lib.getAttributes().get("SizeOfImage").getContent();
            long dllBase = lib.getDllBaseOffset();
            long size = Conversor.hexToLong(sizeHex);
            long dllEnd = dllBase + size;

            /*EntityLib lib32k = null;
             for (EntityLib l : libList) {
             for (String s : _ssdt1Dict) {
             EntityUnicodeStringWin32 uni = (EntityUnicodeStringWin32) l.getAttributes().get("BaseDllName").getContent();
             String lName = (String) uni.getAttributes().get("Name").getContent();
             if (lName.trim().equals(s)) {
             lib32k = l;
             }
             }
             }
             long dllBase32k = 0;
             long dllEnd32k = 0;
             if (lib32k != null) {
             String sizeHex32k = (String) lib32k.getAttributes().get("SizeOfImage").getContent();
             dllBase32k = lib32k.getDllBaseOffset();
             long size32k = Conversor.hexToLong(sizeHex32k);
             dllEnd32k = dllBase + size32k;
             }*/
            for (EntitySSDT s : ssdtList) {
                boolean hookPresent = false;
                EntityPointerReplacementSSDTHook hook = new EntityPointerReplacementSSDTHook();
                for (EntitySDE e : s.getEntryList()) {
                    if (e != null) {
                        List<EntityWindowsFunction> hookedFunctionList = new ArrayList<EntityWindowsFunction>();
                        for (EntityWindowsFunction f : e.getFunctionArray()) {
                            if (f != null) {
                                long fOffset = f.getOffset();
                                if (e.getEntryDescription().equals("nt!KeServiceTable") || e.getEntryDescription().equals("nt!KeServiceTable (Shadow)")) {
                                    if (fOffset < dllBase && fOffset > dllEnd) { //Hook encontrado
                                        hookPresent = true;
                                        f.setHooked(hookPresent);
                                        f.setHookType(hookType);
                                        hookedFunctionList.add(f);
                                    }
                                }
                                /*if (e.getEntryDescription().equals("win32k!W32pServiceTable")) {
                                 if (fOffset < dllBase32k && fOffset > dllEnd32k) { //Hook encontrado
                                 hookPresent = true;
                                 f.setHooked(hookPresent);
                                 f.setHookType(hookType);
                                 hookedFunctionList.add(f);
                                 }
                                 }*/
                            }
                        }
                        if (hookPresent) {
                            hook.setHookedFunctionList(hookedFunctionList);
                        }
                    }
                }

                /**
                 * Prepara colección de hooks a devolver
                 */
                if (hookPresent) {
                    hook.setHookedSSDT(s);
                    hookList.add(hook);
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return hookList;
    }

    @Override
    public List<EntityHook> findTableDumplicationHooks(List<EntitySSDT> ssdtList) {
        List<EntityHook> hookList = null;
        String hookType = EntityDuplicationSSDTHook._HOOK_TYPE;

        try {
            hookList = new ArrayList<EntityHook>();

            /**
             * Separa las tablas conocidas
             */
            EntitySSDT keServiceDescriptorTable = ssdtList.get(0);
            EntitySSDT keServiceDescriptorTableShadow = ssdtList.get(1);
            EntitySDE[] sdeList = keServiceDescriptorTable.getEntryList();
            EntitySDE kiServiceTable = sdeList[0];
            EntitySDE[] sdeListShadow = keServiceDescriptorTableShadow.getEntryList();
            EntitySDE kiServiceTableShadow = sdeList[0];
            EntitySDE w32pServiceTable = sdeList[3];

            for (int i = 1; i < 4; i++) {
                /**
                 * Analizo de KeServiceDescriptorTable, comparando con el resto
                 */
                if (sdeList[i] != null) {
                    if (sdeList[i].isValid()) {
                        this.doCompareFunctions(sdeList[i], kiServiceTable, hookType);
                        this.doCompareFunctions(sdeList[i], kiServiceTableShadow, hookType);
                    }
                }
                /**
                 * Analizo de KeServiceDescriptorTableShadow, comparando con el
                 * resto
                 */
                if (sdeListShadow[i] != null) {
                    if (sdeListShadow[i].isValid()) {
                        this.doCompareFunctions(sdeListShadow[i], kiServiceTable, hookType);
                        this.doCompareFunctions(sdeListShadow[i], kiServiceTableShadow, hookType);
                    }
                }
            }

            /**
             * Prepara colección de hooks a devolver
             */
            EntityDuplicationSSDTHook hook = new EntityDuplicationSSDTHook();
            for (EntitySSDT s : ssdtList) {
                for (EntitySDE e : s.getEntryList()) {
                    if (e != null) {
                        if (e.isHooked()) {
                            hook.setDuplicatedSDE(e);
                            hookList.add(hook);
                        }
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return hookList;
    }

    @Override
    public List<EntityHook> findInLineHooks(List<EntitySSDT> ssdtList) {
        List<EntityHook> hookList = null;
        String hookType = "InLine Hook";

        try {
            hookList = new ArrayList<EntityHook>();
            /**
             * Obtener las operaciones de las funciones en la colección de SDEs
             * de las SSDTs. Comparar con las _suspociousOperations
             */
            for (EntitySSDT s : ssdtList) {
                boolean hookPresent = false;
                for (EntitySDE sde : s.getEntryList()) {
                    if (sde != null) {
                        for (EntityWindowsFunction f : sde.getFunctionArray()) {
                            if (f != null) {
                                for (EntityWindowsFunctionOperation op : f.getOperations()) {
                                    if (op != null) {
                                        for (String opStr : _suspiciousInstructions) {
                                            String operation = (String) op.getAttributes().get("operation").getContent();
                                            if (operation != null) {
                                                if (operation.contains(opStr)) { // Posible InLine Hook
                                                    hookPresent = true;
                                                    op.setHooked(hookPresent);
                                                    op.setHookType(hookType);
                                                }
                                            }
                                        }
                                    }
                                    if (hookPresent) {
                                        f.setHooked(hookPresent);
                                        f.setHookType(hookType);
                                    }
                                }
                            }
                        }
                    }
                }

                /**
                 * Prepara colección de hooks a devolver
                 */
                EntityInLineSSDTHook hook = new EntityInLineSSDTHook();
                if (hookPresent) {
                    hook.setHookedSSDT(s);
                    hookList.add(hook);
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return hookList;
    }

    @Override
    public EntityRootkit getFirstRootkit() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public EntityRootkit getNextRootkit(EntityRootkit rootkit
    ) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public EntityRootkit getPrevRootkit(EntityRootkit rootkit
    ) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Entity getEntityByAttributeValue(Entity entity, String attribute, Object content
    ) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void doCompareFunctions(EntitySDE suspicious, EntitySDE knownSSDT, String hookType) {

        try {
            int cantFuncionesIguales = 0;
            int cantFuncionesDistintas = 0;
            /**
             * Compara la cantidad de entries
             */
            if (suspicious instanceof EntityWin732SDE) {
                if (suspicious.getServiceLimit() == knownSSDT.getServiceLimit()) {
                    /**
                     * Comparar funciones. Según porcentajes, definir si es un
                     * hook de duplicación
                     */
                    EntityWindowsFunction[] sdeFunctions = suspicious.getFunctionArray();
                    EntityWindowsFunction[] kiServiceTableFunctions = knownSSDT.getFunctionArray();
                    for (int j = 0; j < suspicious.getServiceLimit(); j++) {
                        if (sdeFunctions[j].getFunctionVA() == kiServiceTableFunctions[j].getFunctionVA()) {
                            cantFuncionesIguales++;
                        } else {
                            cantFuncionesDistintas++;
                            sdeFunctions[j].setHooked(true);
                            sdeFunctions[j].setHookType(hookType);
                        }
                    }

                    float razonDist = cantFuncionesDistintas / (cantFuncionesIguales + cantFuncionesDistintas);
                    if (razonDist == 1) { // Es otra tabla
                        for (int k = 0; k < suspicious.getServiceLimit(); k++) { // Limpia las 
                            cantFuncionesDistintas++;
                            sdeFunctions[k].setHooked(true);
                            sdeFunctions[k].setHookType(hookType);
                        }
                    } else {
                        suspicious.setHooked(true);
                        suspicious.setFunctionArray(sdeFunctions);
                        suspicious.setDuplicatedWith(knownSSDT.getFunctionTableVAHex());
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public void doAnalizeFunctionOperations(EntitySDE sde, String hookType) {
        try {
            if (sde != null) {
                EntityWindowsFunction[] functionList = sde.getFunctionArray();
                int i = 0;
                boolean hooked = false;
                for (EntityWindowsFunction f : functionList) {
                    if (f != null) {
                        EntityWindowsFunctionOperation[] operations = f.getOperations();
                        for (EntityWindowsFunctionOperation op : operations) {
                            for (String instruction : _suspiciousInstructions) {
                                String operation = (String) op.getAttributes().get("operation").getContent();
                                if (operation.contains(instruction)) { // Inline Hook Suspicious
                                    f.setHooked(true);
                                    f.setHookType(hookType);
                                    op.setHooked(true);
                                    op.setHookType(hookType);
                                    hooked = true;
                                }
                            }
                        }
                    }
                }

                sde.setHooked(hooked);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

}
